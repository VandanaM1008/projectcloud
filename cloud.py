# -*- coding: utf-8 -*-
"""cloud.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1iLUEKvVbQiJ6JC3NS6bz629IeDT8A8XC
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import confusion_matrix, roc_auc_score, roc_curve, precision_score, recall_score, accuracy_score, classification_report, auc, ConfusionMatrixDisplay

# To remove warnings
import warnings
warnings.filterwarnings("ignore")

# loading the dataset to a Pandas DataFrame
df = pd.read_csv('creditcard.csv')

# first 5 rows of the dataset
# df.head()
# Last 5 rows of the dataset
# df.tail()
# Print the first and last few rows of the dataset
df

df.info()

# Checking for missing values in each column
df.isnull().sum()

df.duplicated().sum()

# Removing duplicate rows from data set
df.drop_duplicates(inplace=True)
df.shape

df['Class'].value_counts()

fig = px.pie(data_frame = df,names = 'Class',title = 'Distribution of Classes',)
fig.show()

# Ensure that the 'Amount' column does not have inf values by replacing them with NaN
df['Amount'] = df['Amount'].replace([np.inf, -np.inf], np.nan)

# Optionally, drop rows where 'Amount' is NaN
df = df.dropna(subset=['Amount'])

fig, ax = plt.subplots(1, 2, figsize=(15, 6))
fig.suptitle('Comparison of Normal and Fraud Transactions wrt Amount', fontsize=16)

# KDE plot
sns.kdeplot(df[df['Class'] == 0]['Amount'], label='Amount', ax=ax[0])
sns.kdeplot(df[df['Class'] == 1]['Amount'], label='FraudAmount', ax=ax[0])
ax[0].set_xscale('symlog')
ax[0].set_xlabel('log(Amount)')
ax[0].set_ylabel('Probability')
ax[0].legend()  # Ensure the legend is added to the first plot

# Scatter plot of summary statistics
stats_normal = df[df['Class'] == 0]['Amount'].describe()
stats_fraud = df[df['Class'] == 1]['Amount'].describe()

sns.scatterplot(x=stats_normal.index, y=stats_normal.values, label='Amount', ax=ax[1])
sns.scatterplot(x=stats_fraud.index, y=stats_fraud.values, label='FraudAmount', ax=ax[1])

ax[1].set_yscale('log')
ax[1].set

# Separating the legit & fraudulent data for analysis
legit_transaction = df[df.Class == 0]  # 0 --> normal transaction
fraud_transaction = df[df.Class == 1]  # 1 --> fraudulent transaction

print(legit_transaction.shape)
print(fraud_transaction.shape)

# Statistical descriptive analysis of the data
legit_transaction.Amount.describe()

fraud_transaction.Amount.describe()

# Compare for the both type of transactions
df.groupby('Class').mean()

l_transaction_sample = legit_transaction.sample(n=492)

# Create a new dataframe by concatanatind 2 dataframe
df_new = pd.concat([l_transaction_sample, fraud_transaction], axis=0)

df_new.head()

df_new['Class'].value_counts()

df_new.groupby('Class').mean()

# Ensure that the 'Amount' column does not have inf values by replacing them with NaN
df['Amount'] = df_new['Amount'].replace([np.inf, -np.inf], np.nan)

# Optionally, drop rows where 'Amount' is NaN
df = df.dropna(subset=['Amount'])

fig, ax = plt.subplots(1, 2, figsize=(15, 6))
fig.suptitle('Comparison of Normal and Fraud Transactions wrt Amount', fontsize=16)

# KDE plot
sns.kdeplot(df[df['Class'] == 0]['Amount'], label='Amount', ax=ax[0])
sns.kdeplot(df[df['Class'] == 1]['Amount'], label='FraudAmount', ax=ax[0])
ax[0].set_xscale('symlog')
ax[0].set_xlabel('log(Amount)')
ax[0].set_ylabel('Probability')
ax[0].legend()  # Ensure the legend is added to the first plot

# Scatter plot of summary statistics
stats_normal = df[df['Class'] == 0]['Amount'].describe()
stats_fraud = df[df['Class'] == 1]['Amount'].describe()

sns.scatterplot(x=stats_normal.index, y=stats_normal.values, label='Amount', ax=ax[1])
sns.scatterplot(x=stats_fraud.index, y=stats_fraud.values, label='FraudAmount', ax=ax[1])

ax[1].set_yscale('log')
ax[1].set

from scipy.stats import norm

# Create subplots
f, ax = plt.subplots(4, 2, figsize=(20, 24))

# Distribution plot for V3
sns.distplot(df_new['V3'].loc[df_new['Class'] == 0].values, ax=ax[0][0], fit=norm, hist_kws={'edgecolor':'black'})
ax[0][0].set_title('Distribution of V3 \n (Legit Transactions)', fontsize=14)
sns.distplot(df_new['V3'].loc[df_new['Class'] == 1].values, ax=ax[0][1], fit=norm, hist_kws={'edgecolor':'black'})
ax[0][1].set_title('Distribution of V3 \n (Fraud Transactions)', fontsize=14)

# Distribution plot for V10
sns.distplot(df_new['V10'].loc[df_new['Class'] == 0].values, ax=ax[1][0], fit=norm, hist_kws={'edgecolor':'black'})
ax[1][0].set_title('Distribution of V10 \n (Legit Transactions)', fontsize=14)
sns.distplot(df_new['V10'].loc[df_new['Class'] == 1].values, ax=ax[1][1], fit=norm, hist_kws={'edgecolor':'black'})
ax[1][1].set_title('Distribution of V10 \n (Fraud Transactions)', fontsize=14)
# Distribution plot for V12
sns.distplot(df_new['V12'].loc[df_new['Class'] == 0].values, ax=ax[2][0], fit=norm, hist_kws={'edgecolor':'black'})
ax[2][0].set_title('Distribution of V12 \n (Legit Transactions)', fontsize=14)
sns.distplot(df_new['V12'].loc[df_new['Class'] == 1].values, ax=ax[2][1], fit=norm, hist_kws={'edgecolor':'black'})
ax[2][1].set_title('Distribution of V12 \n (Fraud Transactions)', fontsize=14)

# Distribution plot for V14
sns.distplot(df_new['V14'].loc[df_new['Class'] == 0].values, ax=ax[3][0], fit=norm, hist_kws={'edgecolor':'black'})
ax[3][0].set_title('Distribution of V14 \n (Legit Transactions)', fontsize=14)
sns.distplot(df_new['V14'].loc[df_new['Class'] == 1].values, ax=ax[3][1], fit=norm, hist_kws={'edgecolor':'black'})
ax[3][1].set_title('Distribution of V14 \n (Fraud Transactions)', fontsize=14)

# Adjust layout
plt.tight_layout()
plt.show()

# Create a 3x3 grid of subplots
fig, ax = plt.subplots(3, 3, figsize=(20, 20))
ax = ax.flatten()  # Flatten the array of axes to make indexing easier
fig.suptitle('Box Plot to check for Outliers', fontsize=20)

# Loop through the first 9 columns of the DataFrame and create a boxplot for each
for i, column in enumerate(df.columns[:9]):
    sns.boxplot(data=df_new, x=column, ax=ax[i])
    ax[i].set_title(column)

plt.tight_layout(rect=[0, 0, 1, 0.95])  # Adjust layout to fit title and avoid overlap
plt.show()

# Feature selection for target & features
X = df_new.drop(columns='Class', axis=1)
y = df_new['Class']

# Spliting into Training & Testing Dataset
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, stratify=y, random_state=2)

print(X.shape, X_train.shape, X_test.shape)

# Thain the datasetwith Logistic Regression model
model_lgr = LogisticRegression(max_iter=1000)  # Increase max_iter to 1000
model_lgr.fit(X_train, y_train)

# accuracy on training data
X_train_prediction = model_lgr.predict(X_train)
train_data_accuracy = accuracy_score(X_train_prediction, y_train)
print('Accuracy on Training data : ', train_data_accuracy)


# accuracy on test data
X_test_prediction = model_lgr.predict(X_test)
test_data_accuracy = accuracy_score(X_test_prediction, y_test)
print('Accuracy score on Test Data : ', test_data_accuracy)

# Predict probabilities for the ROC Curve
y_probs = model_lgr.predict_proba(X_test)[:, 1]

# Predict classes for the Confusion Matrix
y_pred = model_lgr.predict(X_test)

# Compute ROC curve and ROC area
fpr, tpr, thresholds = roc_curve(y_test, y_probs)

# Compute ROC AUC score using continuous predictions (probabilities)
roc_auc = roc_auc_score(y_test, y_probs)

# Compute accuracy, precision, recall using binary class predictions
accuracy = accuracy_score(y_test, y_pred)
precision = precision_score(y_test, y_pred)
recall = recall_score(y_test, y_pred)
print('ROC AUC Score:', roc_auc)
print('Accuracy:', accuracy)
print('Precision:', precision)
print('Recall:', recall)

# Predict probabilities for the ROC Curve
y_probs = model_lgr.predict_proba(X_test)[:, 1]

# Compute ROC curve and ROC area
fpr, tpr, thresholds = roc_curve(y_test, y_probs)
roc_auc = roc_auc_score(y_test, y_probs)

# Predict classes for the Confusion Matrix
y_pred = model_lgr.predict(X_test)

# Create subplots: 1 row, 2 columns
fig, ax = plt.subplots(1, 2, figsize=(14, 6))

# Plot ROC Curve
ax[0].plot(fpr, tpr, color='blue', label=f'AUC = {roc_auc:.2f}')
ax[0].plot([0, 1], [0, 1], color='gray', linestyle='--')
ax[0].set_title('ROC Curve')
ax[0].set_xlabel('False Positive Rate')
ax[0].set_ylabel('True Positive Rate')
ax[0].legend(loc='lower right')

# Plot Confusion Matrix
cm = confusion_matrix(y_test, y_pred)
disp = ConfusionMatrixDisplay(confusion_matrix=cm)
disp.plot(ax=ax[1], cmap='Blues', values_format='d')
# Styling for Confusion Matrix
ax[1].set_title('Confusion Matrix', fontsize=16)
ax[1].set_xlabel('Predicted Label', fontsize=14)
ax[1].set_ylabel('True Label', fontsize=14)

# Adjust layout and show plot
plt.tight_layout()
plt.show()

